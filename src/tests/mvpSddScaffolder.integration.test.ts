import * as fs from "fs/promises";
import * as os from "os";
import * as path from "path";
import rimraf from "rimraf";
import { MVPSddScaffolderAgent } from "../agents/mvpSddScaffolder.agent";
import {
  IMVPSddScaffolderAgent,
  MVPSddScaffoldInput,
  MVPSddScaffoldOutput,
  SddComponentType,
} from "../contracts/mvpSddScaffolder.contract";
import { AgentId, ErrorCategory, IAgentError } from "../contracts/types";

describe("MVPSddScaffolderAgent Integration Tests", () => {
  let agent: IMVPSddScaffolderAgent;
  let tempTestDir: string;
  const testAgentId = "test-scaffolder-integration" as AgentId;

  beforeEach(async () => {
    agent = new MVPSddScaffolderAgent();
    // Create a unique temporary directory for each test run
    tempTestDir = await fs.mkdtemp(
      path.join(os.tmpdir(), "sdd-scaffolder-integration-")
    );
  });

  afterEach(async () => {
    // Clean up the temporary directory
    await new Promise<void>((resolve, reject) => {
      rimraf(tempTestDir, (err) => {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  });

  const expectedAgentContent = (
    componentName: string,
    pascalCaseName: string
  ) => `// Blueprint: Auto-generated by MVPSddScaffolderAgent - AGENT
// Purpose: Orchestrates the generation of SDD components (agents, contracts, tests).
// TODO: Implement the agent logic here.
import { AgentId, ContractResult, IAgentError, createNotImplementedError } from '../contracts/types';
import { I${pascalCaseName}Agent, ${pascalCaseName}Input, ${pascalCaseName}Output } from '../contracts/${componentName}.contract';

export class ${pascalCaseName}Agent implements I${pascalCaseName}Agent {
  private agentId: AgentId;

  constructor(agentId: AgentId = '${componentName}-agent' as AgentId) {
    this.agentId = agentId;
  }

  async doSomething(input: ${pascalCaseName}Input): Promise<ContractResult<${pascalCaseName}Output>> {
    // TODO: Implement actual logic
    return { error: createNotImplementedError({ agentId: this.agentId, methodName: 'doSomething', requestingAgentId: input.requestingAgentId }) };
  }
}
`;

  const expectedContractContent = (
    componentName: string,
    pascalCaseName: string
  ) => `// Blueprint: Auto-generated by MVPSddScaffolderAgent - CONTRACT
// Purpose: Defines the contract for the ${pascalCaseName} agent.
// TODO: Define the input, output, and methods for this agent's contract.
import { AgentId, ContractResult, IAgentError } from './types';

// CONTRACT_VERSION: 0.1.0

export interface ${pascalCaseName}Input {
  requestingAgentId: AgentId;
  // TODO: Define input properties
  data: string;
}

export interface ${pascalCaseName}Output {
  // TODO: Define output properties
  message: string;
}

export interface I${pascalCaseName}Agent {
  doSomething(input: ${pascalCaseName}Input): Promise<ContractResult<${pascalCaseName}Output>>;
}
`;

  const expectedTestContent = (
    componentName: string,
    pascalCaseName: string
  ) => `// Blueprint: Auto-generated by MVPSddScaffolderAgent - TEST
// Purpose: Provides contract tests for the ${pascalCaseName} agent.
// TODO: Implement comprehensive tests for all contract methods.
import { I${pascalCaseName}Agent, ${pascalCaseName}Input, ${pascalCaseName}Output } from '../contracts/${componentName}.contract';
import { ${pascalCaseName}Agent } from '../agents/${componentName}.agent';
import { AgentId, ContractResult, ErrorCategory, IAgentError, createNotImplementedError } from '../contracts/types';

describe('${pascalCaseName}Agent Contract Tests', () => {
  let agent: I${pascalCaseName}Agent;
  const mockRequestingAgentId = 'test-rig-agent' as AgentId;

  beforeEach(() => {
    agent = new ${pascalCaseName}Agent();
  });

  describe('doSomething', () => {
    it('should return a NotImplementedError for initial stub', async () => {
      const input: ${pascalCaseName}Input = {
        requestingAgentId: mockRequestingAgentId,
        data: 'test data',
      };
      const result: ContractResult<${pascalCaseName}Output> = await agent.doSomething(input);

      expect(result.error).toBeDefined();
      expect(result.result).toBeUndefined();
      const error = result.error as IAgentError;
      expect(error.category).toEqual(ErrorCategory.NOT_IMPLEMENTED);
      expect(error.message).toContain('doSomething is not implemented');
      expect(error.agentId).toEqual('${componentName}-agent');
      expect(error.methodName).toEqual('doSomething');
      expect(error.requestingAgentId).toEqual(mockRequestingAgentId);
    });

    // TODO: Add more tests for happy paths and other error conditions
    // once the agent method is implemented.
  });
});
`;

  it("should create agent, contract, and test files for FULL_AGENT_SET in the specified directory", async () => {
    const componentName = "myNewComponent";
    const pascalCaseName = "MyNewComponent";
    const input: MVPSddScaffoldInput = {
      requestingAgentId: testAgentId,
      sddComponentType: SddComponentType.FULL_AGENT_SET,
      componentName,
      targetDirectory: tempTestDir,
      templateVariables: { user: "TestUser", version: "0.0.1" },
    };

    const result = await agent.generateSddScaffold(input);

    expect(result.error).toBeUndefined();
    expect(result.result).toBeDefined();
    const output = result.result as MVPSddScaffoldOutput;

    expect(output.overallStatus).toBe("success");
    expect(output.summaryMessage).toContain(
      "Successfully generated and wrote 3 files"
    );
    expect(output.generatedFiles).toHaveLength(3);

    const expectedAgentPath = path.join(
      tempTestDir,
      "agents",
      `${componentName}.agent.ts`
    );
    const expectedContractPath = path.join(
      tempTestDir,
      "contracts",
      `${componentName}.contract.ts`
    );
    const expectedTestPath = path.join(
      tempTestDir,
      "tests",
      `${componentName}.contract.test.ts`
    );

    expect(
      output.generatedFiles?.some((f) => f.filePath === expectedAgentPath)
    ).toBe(true);
    expect(
      output.generatedFiles?.some((f) => f.filePath === expectedContractPath)
    ).toBe(true);
    expect(
      output.generatedFiles?.some((f) => f.filePath === expectedTestPath)
    ).toBe(true);

    // Verify agent file content
    const agentContent = await fs.readFile(expectedAgentPath, "utf-8");
    expect(agentContent).toEqual(
      expectedAgentContent(componentName, pascalCaseName)
    );

    // Verify contract file content
    const contractContent = await fs.readFile(expectedContractPath, "utf-8");
    expect(contractContent).toEqual(
      expectedContractContent(componentName, pascalCaseName)
    );

    // Verify test file content
    const testContent = await fs.readFile(expectedTestPath, "utf-8");
    expect(testContent).toEqual(
      expectedTestContent(componentName, pascalCaseName)
    );
  });

  it("should create only an agent file for SddComponentType.AGENT", async () => {
    const componentName = "myAgentOnly";
    const pascalCaseName = "MyAgentOnly";
    const input: MVPSddScaffoldInput = {
      requestingAgentId: testAgentId,
      sddComponentType: SddComponentType.AGENT,
      componentName,
      targetDirectory: tempTestDir,
    };

    const result = await agent.generateSddScaffold(input);
    expect(result.error).toBeUndefined();
    const output = result.result as MVPSddScaffoldOutput;
    expect(output.overallStatus).toBe("success");
    expect(output.summaryMessage).toContain(
      "Successfully generated and wrote 1 files"
    );
    expect(output.generatedFiles).toHaveLength(1);

    const expectedAgentPath = path.join(
      tempTestDir,
      "agents",
      `${componentName}.agent.ts`
    );
    expect(output.generatedFiles?.[0].filePath).toEqual(expectedAgentPath);
    const agentContent = await fs.readFile(expectedAgentPath, "utf-8");
    expect(agentContent).toEqual(
      expectedAgentContent(componentName, pascalCaseName)
    );

    // Ensure other files are not created
    const expectedContractPath = path.join(
      tempTestDir,
      "contracts",
      `${componentName}.contract.ts`
    );
    const expectedTestPath = path.join(
      tempTestDir,
      "tests",
      `${componentName}.contract.test.ts`
    );
    await expect(fs.access(expectedContractPath)).rejects.toThrow(); // Should not exist
    await expect(fs.access(expectedTestPath)).rejects.toThrow(); // Should not exist
  });

  it("should create only a contract file for SddComponentType.CONTRACT", async () => {
    const componentName = "myContractOnly";
    const pascalCaseName = "MyContractOnly";
    const input: MVPSddScaffoldInput = {
      requestingAgentId: testAgentId,
      sddComponentType: SddComponentType.CONTRACT,
      componentName,
      targetDirectory: tempTestDir,
    };

    const result = await agent.generateSddScaffold(input);
    expect(result.error).toBeUndefined();
    const output = result.result as MVPSddScaffoldOutput;
    expect(output.overallStatus).toBe("success");
    expect(output.summaryMessage).toContain(
      "Successfully generated and wrote 1 files"
    );
    expect(output.generatedFiles).toHaveLength(1);

    const expectedContractPath = path.join(
      tempTestDir,
      "contracts",
      `${componentName}.contract.ts`
    );
    expect(output.generatedFiles?.[0].filePath).toEqual(expectedContractPath);
    const contractContent = await fs.readFile(expectedContractPath, "utf-8");
    expect(contractContent).toEqual(
      expectedContractContent(componentName, pascalCaseName)
    );

    const expectedAgentPath = path.join(
      tempTestDir,
      "agents",
      `${componentName}.agent.ts`
    );
    const expectedTestPath = path.join(
      tempTestDir,
      "tests",
      `${componentName}.contract.test.ts`
    );
    await expect(fs.access(expectedAgentPath)).rejects.toThrow();
    await expect(fs.access(expectedTestPath)).rejects.toThrow();
  });

  it("should create only a test file for SddComponentType.TEST", async () => {
    const componentName = "myTestOnly";
    const pascalCaseName = "MyTestOnly";
    const input: MVPSddScaffoldInput = {
      requestingAgentId: testAgentId,
      sddComponentType: SddComponentType.TEST,
      componentName,
      targetDirectory: tempTestDir,
    };

    const result = await agent.generateSddScaffold(input);
    expect(result.error).toBeUndefined();
    const output = result.result as MVPSddScaffoldOutput;
    expect(output.overallStatus).toBe("success");
    expect(output.summaryMessage).toContain(
      "Successfully generated and wrote 1 files"
    );
    expect(output.generatedFiles).toHaveLength(1);

    const expectedTestPath = path.join(
      tempTestDir,
      "tests",
      `${componentName}.contract.test.ts`
    );
    expect(output.generatedFiles?.[0].filePath).toEqual(expectedTestPath);
    const testContent = await fs.readFile(expectedTestPath, "utf-8");
    expect(testContent).toEqual(
      expectedTestContent(componentName, pascalCaseName)
    );

    const expectedAgentPath = path.join(
      tempTestDir,
      "agents",
      `${componentName}.agent.ts`
    );
    const expectedContractPath = path.join(
      tempTestDir,
      "contracts",
      `${componentName}.contract.ts`
    );
    await expect(fs.access(expectedAgentPath)).rejects.toThrow();
    await expect(fs.access(expectedContractPath)).rejects.toThrow();
  });

  it("should return an error if targetDirectory does not exist and cannot be created (e.g. permission issue - simulated by making it a file)", async () => {
    const componentName = "testFailure";
    // Simulate an unwritable target directory by creating a file with the same name
    const filePath = path.join(os.tmpdir(), "unwritable-dir-sim");
    await fs.writeFile(filePath, "I am a file, not a directory");

    const input: MVPSddScaffoldInput = {
      requestingAgentId: testAgentId,
      sddComponentType: SddComponentType.AGENT,
      componentName,
      targetDirectory: filePath, // Attempting to use the file path as a directory
    };

    const result = await agent.generateSddScaffold(input);

    expect(result.result).toBeUndefined();
    expect(result.error).toBeDefined();
    const error = result.error as IAgentError;
    expect(error.category).toBe(ErrorCategory.FILE_SYSTEM_ERROR);
    expect(error.message).toMatch(/Failed to write file/); // Or more specific to directory creation
    expect(error.details).toMatch(
      /Error trying to ensure directory exists or write file/
    );

    // Clean up the dummy file
    await fs.unlink(filePath);
  });

  it("should return an error for invalid componentName", async () => {
    const input: MVPSddScaffoldInput = {
      requestingAgentId: testAgentId,
      sddComponentType: SddComponentType.AGENT,
      componentName: "", // Invalid
      targetDirectory: tempTestDir,
    };
    const result = await agent.generateSddScaffold(input);
    expect(result.result).toBeUndefined();
    expect(result.error).toBeDefined();
    const error = result.error as IAgentError;
    expect(error.category).toBe(ErrorCategory.INVALID_REQUEST);
    expect(error.message).toContain("Component name cannot be empty");
  });

  it("should return an error for invalid targetDirectory", async () => {
    const input: MVPSddScaffoldInput = {
      requestingAgentId: testAgentId,
      sddComponentType: SddComponentType.AGENT,
      componentName: "myValidComponent",
      targetDirectory: "", // Invalid
    };
    const result = await agent.generateSddScaffold(input);
    expect(result.result).toBeUndefined();
    expect(result.error).toBeDefined();
    const error = result.error as IAgentError;
    expect(error.category).toBe(ErrorCategory.INVALID_REQUEST);
    expect(error.message).toContain("Target directory cannot be empty");
  });
});
